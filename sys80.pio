; D0      <- IN, OUT, SET first
; D1
; D2
; D3
; D4
; D5      <- SIDE first
; D6
; D7      <- OUT, SET last
; /RD     <- JMP PIN


; SM 0
; 11 instructions
; Port #0 (read/write)
; X holds the selected register index.
; Y holds the most significant 24 bits of the READ_ADDR and WRITE_ADDR DMA channel registers modified on write.
.PROGRAM sys80_port0
.SIDE_SET 3 OPT PINDIRS
.DEFINE PUBLIC cs_pin 26

write:
  MOV X, PINS
  IN Y, 24
  IN X, 8                           ; auto-push to READ_ADDR
  IN Y, 24
  IN X, 8                           ; auto-push to WRITE_ADDR

PUBLIC entry:  
.WRAP_TARGET
  WAIT 1 GPIO cs_pin
  SET PINDIRS, 0b00000  SIDE 0b000
  WAIT 0 GPIO cs_pin
  JMP PIN write

read:
  MOV PINS, X
  SET PINDIRS, 0b11111  SIDE 0b111
  .WRAP



; SM 1
; 7 instructions
; Port #1 (read) accesses the register addressed by port #0.
.PROGRAM sys80_read_port1
.SIDE_SET 3 OPT PINDIRS
.DEFINE PUBLIC cs_pin 27

PUBLIC entry:
.WRAP_TARGET
  WAIT 1 GPIO cs_pin
  SET PINDIRS, 0b00000  SIDE 0b000
  WAIT 0 GPIO cs_pin
  JMP PIN entry                   ; skip writes

read:
  PUSH                            ; Push one to trigger the DMA channel which
                                  ; reads register data from internal SRAM.
  SET PINDIRS, 0b11111  SIDE 0b111
  OUT PINS, 8                     ; auto-pull register data from TX FIFO
  .WRAP


; SM 2
; 5 instructions
; Port #1 (write) accesses the register addressed by port #0.
.PROGRAM sys80_write_port1
.SIDE_SET 3 OPT PINDIRS
.DEFINE PUBLIC cs_pin 27

write:
  PUSH                            ; Push dummy value to chain to DMA channel which
                                  ; will write register data to internal SRAM.
  IN PINS, 8                      ; auto-push register data

PUBLIC entry:
.WRAP_TARGET
  WAIT 1 GPIO cs_pin
  WAIT 0 GPIO cs_pin
  JMP PIN write                   ; skip reads
  .WRAP


; SM 3
; 8 instructions
; Port #2 (write) Streams data to ring buffer in internal SRAM.
; Port #2 (read) Counts bytes written to this port.
.PROGRAM sys80_port2
.SIDE_SET 3 OPT PINDIRS
.DEFINE PUBLIC cs_pin 28

write:
  IN PINS, 8                      ; auto-push every 32-bits

  JMP X-- entry
  
PUBLIC entry:
.WRAP_TARGET
  WAIT 1 GPIO cs_pin
  SET PINDIRS, 0b00000  SIDE 0b000

  WAIT 0 GPIO cs_pin
  JMP PIN write

read:
  MOV PINS, ~X
  SET PINDIRS, 0b11111  SIDE 0b111
  .WRAP


% c-sdk {
static inline void sys80_program_init(PIO pio, uint sm, uint offset) {
  const static uint sm_wrap[4] = {
    sys80_port0_wrap,
    sys80_read_port1_wrap,
    sys80_write_port1_wrap,
    sys80_port2_wrap,
  };

  const static uint sm_wrap_target[4] = {
    sys80_port0_wrap_target,
    sys80_read_port1_wrap_target,
    sys80_write_port1_wrap_target,
    sys80_port2_wrap_target,
  };

  const static uint sm_entry[4] = {
    sys80_port0_offset_entry,
    sys80_read_port1_offset_entry,
    sys80_write_port1_offset_entry,
    sys80_port2_offset_entry,
  };

  const static int sm_auto_pull[4] = {
    8,
    8,
    8,
    -1,
  };

  const static int sm_auto_push[4] = {
    32,
    8,
    8,
    32,
  };

  const static bool sm_in_shift_dir[4] = {
    false,  // left
    false,  // left
    false,  // left
    true,   // right
  };

  pio_sm_config c = pio_get_default_sm_config();

  sm_config_set_wrap(&c, offset + sm_wrap_target[sm], offset + sm_wrap[sm]);

  sm_config_set_in_pins(&c, DATA_PINS);
  sm_config_set_in_shift(&c, sm_in_shift_dir[sm], sm_auto_push[sm] >= 0, sm_auto_push[sm]);

  sm_config_set_out_pins(&c, DATA_PINS, 8);
  sm_config_set_out_shift(&c, true /*right shift*/, sm_auto_pull[sm] >= 0, sm_auto_pull[sm]);

  sm_config_set_set_pins(&c, DATA_PINS, 5);

  sm_config_set_sideset(&c, 4, true, true);  // Must match .SIDE_SET directive
  sm_config_set_sideset_pins(&c, DATA_PINS + 5);

  sm_config_set_jmp_pin(&c, RD_PIN);

  pio_sm_set_consecutive_pindirs(pio, sm, DATA_PINS, 8, false /*pindir*/ );

  // Configure the data pins so they can be controlled via PINDIRS but currently still inputs.
  // TODO: this should be done externally to sys80_program_init; it isn't for a single SM.
  for (int i = 0; i < 8; ++i) {
     pio_gpio_init(pio, DATA_PINS + i);
  }

  // Initialize X register for SM 3.
  pio_sm_exec(pio, sm, pio_encode_mov_not(pio_x, pio_null));

  pio_sm_init(pio, sm, offset + sm_entry[sm], &c);
	pio_sm_set_enabled(pio, sm, true);
}
%}

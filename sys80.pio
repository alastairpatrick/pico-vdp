  .PROGRAM sys80
  .SIDE_SET 3 OPT PINDIRS
  
	; A0      <- IN first
	; A1
	; D0      <- SET first
	; D1
	; D2
	; D3
	; D4
	; D5      <- SIDE first
	; D6
	; D7      <- SET last
  ; /CS
  ; /RD     <- JMP PIN

  ; relative to IN pin mapping
  .DEFINE PUBLIC d0_pin 2
  .DEFINE PUBLIC cs_pin 10
  .DEFINE PUBLIC rd_pin 11

finish_read:
  SET PINDIRS, 0b11111  SIDE 0b111

PUBLIC entry:  
loop:
  WAIT 1 PIN cs_pin
  SET PINDIRS, 0b00000  SIDE 0b000

  WAIT 0 PIN cs_pin
  MOV OSR, PINS
  OUT X, d0_pin
  JMP X!=Y loop                   ; only SM that handles whis port continues beyond here

  ; Jump to one of the handle_X routines, depending on SM configuration
  .WRAP

  // PIO 1 SM 0 handles both reads and writes to port #0 - the GI address port.
  // ISR holds the current address.
  // Writes to this port are pushed twice to the RX FIFO, updating the
  // low 8-bits of the READ_ADDR and WRITE_ADDR of the DMA channels attached to SM1 and SM2.

  ; .WRAP_TARGET for SM 0
PUBLIC handle_access0:
  JMP PIN write0

read0:
  MOV PINS, ISR
  JMP finish_read

write0:
  IN OSR, 8                       ; auto-push register address
  PUSH                            ; push register address second time, leaving address in ISR
  JMP loop


  // PIO 1 SM 1 handles reads to port #1 - the GI data port.

  ; .WRAP_TARGET for SM 1
PUBLIC handle_read1:
  JMP PIN loop                    ; ignore writes to port #1

  PUSH                            ; push dummy value to chain to the DMA channel that will load the register
  PULL                            ; pull register value
  MOV PINS, OSR
  JMP finish_read

  // PIO 1 SM 2 handles writes to port #1 - the GI data port.

  ; .WRAP_TARGET for SM 2
PUBLIC handle_write1:
  JMP PIN write1                  ; only handle writes to port #1
  JMP loop

write1:                           ; TODO: same as write0
  IN OSR, 8                       ; push dummy value to chain to the DMA channel that will store the register
  PUSH                            ; auto-push register data
  JMP loop

  // PIO 1 SM 3 handlers accesses to port #2 - the VDP port

PUBLIC handle_access2:
  JMP PIN write2

read2:                            ; TODO: same as read0
  MOV PINS, ISR
  JMP finish_read

write2:
  MOV ISR, ~ISR
  IN OSR, 8                      ; Auto-push every 16-bits
  JMP loop


% c-sdk {
static inline void sys80_program_init(PIO pio, uint sm, uint offset, uint pins, int pio_clk_div) {
  const static uint g_sm_handlers[4] = {
    sys80_offset_handle_access0,
    sys80_offset_handle_read1,
    sys80_offset_handle_write1,
    sys80_offset_handle_access2,
  };

  const static uint g_sm_ports[4] = {
    0,
    1,
    1,
    2
  };

  const static uint g_sm_auto_push[4] = {
    8,
    8,
    8,
    16
  };

	pio_sm_config c = sys80_program_get_default_config(offset);

  sm_config_set_in_pins(&c, pins);
  sm_config_set_set_pins(&c, pins + sys80_d0_pin, 8);
  sm_config_set_sideset_pins(&c, pins + sys80_d0_pin + 5);
  sm_config_set_jmp_pin(&c, pins + sys80_rd_pin);

  sm_config_set_wrap(&c, offset + g_sm_handlers[sm], offset + sys80_wrap);

  sm_config_set_in_shift(&c, false /*left shift*/, true /*auto-push*/, g_sm_auto_push[sm]);
  sm_config_set_out_shift(&c, true /*right shift*/, false /*auto-pull*/, 32);

  pio_sm_init(pio, sm, sys80_offset_entry, &c);

  // Configure the data pins so they can be controlled via PINDIRS but currently still inputs.
  for (int i = 0; i < 8; ++i) {
     pio_gpio_init(pio, pins + sys80_d0_pin + i);
  }
  pio_sm_set_consecutive_pindirs(pio, sm, pins + sys80_d0_pin, 8, false /*pindir*/ );

  pio_sm_exec(pio, sm, pio_encode_set(pio_isr, 0));
  pio_sm_exec(pio, sm, pio_encode_set(pio_y, g_sm_ports[sm]));

	pio_sm_set_enabled(pio, sm, true);
}
%}

.define gpio_rd 12
.define gpio_wr 13
  
  
.program read_vdp
.side_set 3 opt pindirs

	; WAIT
	; D0	<- SET first
	; D1
	; D2
	; D3
	; D4
	; D5
	; D6
	; D7	<- SET last
	; A0
	; A1	<- JMP PIN
	
	; The value read from this port is stored in the PIO's OSR register so can
	; be read without blocking or wait states. CPU updates the value by causing
	; the PIO to execute a PULL instruction after pushing the new value into the
	; TX FIFO.
	
	; 6 instructions

do_read:
	mov pins, osr
  set pindirs, 0b11111    side 0b111
	
public read_vdp_entry:
  .wrap_target
	wait 1 gpio gpio_rd
  set pindirs, 0b00000    side 0b000
	wait 0 gpio gpio_rd
	jmp pin do_read
	.wrap
	
	


.program write_vdp
	
	; WAIT
	; D0	<- IN first
	; D1
	; D2
	; D3
	; D4
	; D5
	; D6
	; D7	<- IN last
	; A0
	; A1	<- JMP PIN
	
	; 4 instructions
	
do_write:
	; This could in theory block if the RX FIFO filled up. However, there is
	; a DMA channel dedicated to copying data from the RX FIFO into a ring buffer
	; in internal RAM. This is fast enough to ensure that this never blocks.
	; Wait states are not required.
	in pins, 8
	
public write_vdp_entry:
  .wrap_target
	wait 1 gpio gpio_rd
	wait 0 gpio gpio_wr
	jmp pin do_write
	.wrap




.program read_ay
.side_set 4 opt pindirs
	
	; WAIT	<- OUT, SET first
	; D0
	; D1
	; D2
	; D3
	; D4 <- SIDE first
	; D5
	; D6
	; D7	<- OUT last
	; A0	<- IN first, last
	; A1	<- JMP PIN
	
	; 8 instructions


public read_ay_entry:
loop:
  .wrap_target	
	wait 1 gpio gpio_rd
	set pindirs, 0b10000 side 0b0000   ; make only WAIT an output
	wait 0 gpio gpio_rd
	jmp pin loop
	
do_read:
  set pins, 1                         ; assert WAIT
	set pindirs, 0b11111	side 0b1111   ; make WAIT and D0-7 outputs
	in pins, 1			      		          ; write address to FIFO.
	out pins, 9				                  ; read data from FIFO, blocking with WAIT asserted. deassert WAIT. 
	.wrap
	


	
.program write_ay
		
	; WAIT	<- SET first, last
	; D0	<- IN first
	; D1
	; D2
	; D3
	; D4
	; D5
	; D6
	; D7
	; A0	<- IN last
	; A1	<- JMP PIN
	
	; 6 instructions
	
  ; TODO: implement ARM ISR, calculate maximum interrupt latency and determine whether wait states are necessary.

public write_ay_entry:
loop:
  .wrap_target
	wait 1 gpio gpio_wr
	wait 0 gpio gpio_wr
	jmp pin loop

do_write:
  set pins, 1                         ; assert WAIT
	in pins, 9			                    ; potentially blocks with /WAIT asserted.
  set pins, 0                         ; deassert WAIT
  .wrap
